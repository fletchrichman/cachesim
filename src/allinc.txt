/*
 * asscache.h
 *
 *  Created on: Apr 23, 2012
 *      Author: Tim
 */

#ifndef ASSCACHE_H_
#define ASSCACHE_H_

#include "cache.h"
#include "asscacheset.h"
#include "lrunode.h"

class AssCache : public Cache
{
public:
	AssCache(cacheLevel level, uint32 cacheSize, uint32 blockSize, uint32 assoc);

	uint32 getTagFromReference(uint32 reference);
	uint32 getIndexFromReference(uint32 reference);

	checkRet checkInCache(uint32 reference);
	eviction checkAddRequiresEviction(uint32 reference);
	uint32 getAddressToEvict(uint32 reference);
	void addToCache(uint32 reference);
	void write(uint32 reference);

	void printCache();
private:
	uint32 reconstructAddress(uint32 tag, uint32 index);

	AssCacheSet* m_cache;

	uint32 m_numSets;
	uint32 m_numWays;
};




#endif /* ASSCACHE_H_ */
/*
 * asscacheset.h
 *
 *  Created on: May 1, 2012
 *      Author: Tim
 */

#ifndef ASSCACHESET_H_
#define ASSCACHESET_H_

#include "lrunode.h"
#include "types.h"

class AssCacheSet
{
public:
	AssCacheSet();
	void Init(uint32 numWays);

	bool getValid(uint32 way);
	void setValid(uint32 way, bool valid);

	bool getDirty(uint32 way);
	void setDirty(uint32 way, bool dirty);

	uint32 getTag(uint32 way);
	void setTag(uint32 way, uint32 tag);

	uint32 getLruWay();
	void updateLru(uint32 usedWay);

private:
	bool* m_valids;
	bool* m_dirtys;

	uint32*  m_tags;

	LruNode* m_leastRuNode;
	LruNode* m_mostRuNode;
	LruNode* m_lruNodeArray;
};



#endif /* ASSCACHESET_H_ */
/*
 * cache.h
 *
 *  Created on: Apr 23, 2012
 *      Author: Tim
 */

#ifndef CACHE_H_
#define CACHE_H_

#include "types.h"

class Cache
{
public:
	enum checkRet
	{
		CR_HIT = 0,
		CR_MISS
	};

	enum eviction{
		E_DIRTY=0,
		E_CLEAN,
		E_NOEVICT,
	};

	enum cacheLevel
	{
		CL_L1I=0,
		CL_L1D,
		CL_L2,
		CL_NUMLEVELS
	};

	virtual uint32 getTagFromReference(uint32 reference) = 0;
	virtual uint32 getIndexFromReference(uint32 reference) = 0;

	virtual checkRet checkInCache(uint32 reference) = 0;
	virtual eviction checkAddRequiresEviction(uint32 reference) = 0;
	virtual uint32 getAddressToEvict(uint32 reference) = 0;
	virtual void addToCache(uint32 reference) = 0;
	virtual void write(uint32 reference) = 0;

	virtual void printCache() = 0;

	static Cache* CreateCache(cacheLevel level, uint32 cacheSize, uint32 blockSize, uint32 assoc);

protected:
	Cache(cacheLevel level);
	virtual ~Cache();

	virtual uint32 reconstructAddress(uint32 tag, uint32 index) = 0;

	uint32 m_blockSize;
	uint32 m_numIndexBits;
	uint32 m_numTagBits;
	uint32 m_numBitsWordInBlock;
	uint32 m_numBitsByteInWord;
	cacheLevel m_level;
};


#endif /* CACHE_H_ */
/*
 * config.h
 *
 *  Created on: Apr 23, 2012
 *      Author: Tim
 */

#ifndef CONFIG_H_
#define CONFIG_H_

#include "types.h"

//L1 cache configuration variables
extern uint32 L1_block_size;
extern uint32 L1_cache_size;
extern uint32 L1_assoc;
extern uint32 L1_hit_time;
extern uint32 L1_miss_time;

//L2 cache configuration variables
extern uint32 L2_block_size;
extern uint32 L2_cache_size;
extern uint32 L2_assoc;
extern uint32 L2_hit_time;
extern uint32 L2_miss_time;
extern uint32 L2_transfer_time;
extern uint32 L2_bus_width;

//Main memory configuration values
extern uint32 mem_sendaddr;
extern uint32 mem_ready;
extern uint32 mem_chunktime;
extern uint32 mem_chunksize;

//#define USE_STD_IN

#include <string>

using namespace std;

class Config
{
public:
	static bool readConfigFile(string filename);
};


#endif /* CONFIG_H_ */
/*
 * dmcache.h
 *
 *  Created on: Apr 23, 2012
 *      Author: Tim
 */

#ifndef DMCACHE_H_
#define DMCACHE_H_

#include "cache.h"
#include "dmcacheblock.h"

class DMCache : public Cache
{
public:
	DMCache(cacheLevel level, uint32 cacheSize, uint32 blockSize);

	uint32 getTagFromReference(uint32 reference);
	uint32 getIndexFromReference(uint32 reference);

	checkRet checkInCache(uint32 reference);
	eviction checkAddRequiresEviction(uint32 reference);
	uint32 getAddressToEvict(uint32 reference);
	void addToCache(uint32 reference);
	void write(uint32 reference);

	void printCache();
private:
	uint32 reconstructAddress(uint32 tag, uint32 index);

	DMCacheBlock* m_cache;
	uint32 m_numBlocks;
};



#endif /* DMCACHE_H_ */
/*
 * dmcacheblock.h
 *
 *  Created on: Apr 23, 2012
 *      Author: Tim
 */

#ifndef DMCACHEBLOCK_H_
#define DMCACHEBLOCK_H_

#include "types.h"

class DMCacheBlock
{
public:
	DMCacheBlock(bool valid = false, bool dirty = false, uint32 tag = 0);

	bool GetValid();
	void SetValid(bool valid);

	bool GetDirty();
	void SetDirty(bool dirty);

	uint32 GetTag();
	void SetTag(uint32 tag);
private:
	bool m_valid;
	bool m_dirty;
	uint32 m_tag;
};



#endif /* DMCACHEBLOCK_H_ */
/*
 * instruction.h
 *
 *  Created on: Apr 23, 2012
 *      Author: Tim
 */

#ifndef INSTRUCTION_H_
#define INSTRUCTION_H_

#include "types.h"

class Instruction
{
public:
	enum opcode
	{
		O_MinimumValue = 0,
		O_Load = 0,
		O_Store,
		O_Branch,
		O_Computation,
		O_NumValues,
		O_InvalidValue
	};

	typedef union
	{
		uint32 ldstAddr;
		uint32 brTaken;
		uint32 compLatency;
	} executionInfo;

	static char opcodeSymbol[];

	opcode GetOpcode();
	void SetOpcode(opcode op);

	uint32 GetPc();
	void SetPc(uint32 pc);

	uint32 GetExecInfo();
	void SetExecInfo(uint32 exInfo);

	uint64 GetInstrNum();
	void SetInstrNum(uint64 instrNum);


private:
	opcode m_opcode;
	uint32 m_pc;
	executionInfo m_exInfo;
	uint64 m_instrNum;
};

#endif /* INSTRUCTION_H_ */
/*
 * lrunode.h
 *
 *  Created on: May 1, 2012
 *      Author: Tim
 */

#ifndef LRUNODE_H_
#define LRUNODE_H_

#include "types.h"

class LruNode
{
public:
	LruNode();

	LruNode* getNext();
	void setNext(LruNode* next);
	LruNode* getPrev();
	void setPrev(LruNode* prev);
	uint32 getWay();
	void setWay(uint32 way);
private:
	LruNode* m_next;
	LruNode* m_prev;

	uint32 m_way;
};


#endif /* LRUNODE_H_ */
/*
 * results.h
 *
 *  Created on: Apr 23, 2012
 *      Author: Tim
 */

#ifndef RESULTS_H_
#define RESULTS_H_

#include "cache.h"
#include "instruction.h"

class Results
{
public:
	Results();
	void PrintResults();

	void ParsedInstruction(Instruction::opcode opcode);
	void InstructionRef(Cache::checkRet L1Hit,
						Cache::eviction L1Evict,
						Cache::checkRet L2Hit,
						Cache::eviction L2Evict);

	void L1DEvict(Cache::eviction L1DEvict);
	void L2Evict(Cache::eviction L2Evict);
	void L1DRef(Cache::checkRet L1DHit);
	void L2Ref(Cache::checkRet L2Hit);
	void AddExecInfoTime(uint32 execTime);
	uint64 GetExecTime();
	void AddCycleCount(Instruction::opcode opcode,uint64 cycle);

private:
	uint64 m_numTotal;
	uint64 m_numLoad;
	uint64 m_numBranch;
	uint64 m_numStore;
	uint64 m_numComp;

	uint64 m_cycleTotal;
	uint64 m_cycleLoad;
	uint64 m_cycleBranch;
	uint64 m_cycleStore;
	uint64 m_cycleComp;

	uint64 m_execTime;

	uint64 m_instRefs;
	uint64 m_dataRefs;

	uint64 m_hitCount[Cache::CL_NUMLEVELS];
	uint64 m_missCount[Cache::CL_NUMLEVELS];
	uint64 m_accessTotal[Cache::CL_NUMLEVELS];
	uint64 m_kickouts[Cache::CL_NUMLEVELS];
	uint64 m_dirtyKickouts[Cache::CL_NUMLEVELS];
	uint64 m_transfers[Cache::CL_NUMLEVELS];
};



#endif /* RESULTS_H_ */
/*
 * simulator.h
 *
 *  Created on: Apr 23, 2012
 *      Author: Tim
 */

#ifndef SIMULATOR_H_
#define SIMULATOR_H_

#include "instruction.h"
#include "results.h"
#include "cache.h"

class Simulator
{
public:
	static void HandleInstruction(Instruction* instr,
								  Cache* L1I,
								  Cache* L1D,
								  Cache* L2,
								  Results* results);
};


#endif /* SIMULATOR_H_ */
/*
 * trace.h
 *
 *  Created on: Apr 23, 2012
 *      Author: Tim
 */

#ifndef TRACE_H_
#define TRACE_H_

#include <stdio.h>
#include <string>

#include "instruction.h"
#include "results.h"

class Trace
{
public:
	static int OpenTraceFile(std::string filename);
	static int GetInstruction(Instruction* instr, Results* results);
	static void PrintInstruction(Instruction* instr);

private:
	static FILE* m_traceFile;
	static uint64 m_instrNum;
};

#endif /* TRACE_H_ */
/*
 * types.h
 *
 *  Created on: Apr 23, 2012
 *      Author: Tim
 */

#ifndef TYPES_H_
#define TYPES_H_

#define WORD_SIZE 32

typedef unsigned int uint32;
typedef unsigned long long uint64;

#endif /* TYPES_H_ */
